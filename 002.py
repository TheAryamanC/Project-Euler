import time

### Problem 2

## Problem statement:
# Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
# 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
# By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

## Solution 1:
# We can solve this problem by generating the Fibonacci sequence up to four million, and then summing all the even numbers
# This is the only viable solution, however the method of generating numbers will differ in the solutions
# Let's start by generating the Fibonacci sequence using a recursive function - this is the way most students are taught to generate the Fibonacci sequence

def fibonacci(n):
    return 1 if (n == 0 or n == 1) else (fibonacci(n - 1) + fibonacci(n - 2))

print("Solution 1: Recursive function")
start = time.time()
n = 2
list_of_even_fibonacci = [2]
while fibonacci(n) < 4000000:
    if fibonacci(n) % 2 == 0:
        list_of_even_fibonacci.append(fibonacci(n))
    n += 1
print("Sum of even-valued terms in Fibonacci sequence below 4000000:", sum(list_of_even_fibonacci))
end = time.time()
print("Time taken (ns):", end - start) # ??? time

# This method is so slow that I can't even get a time measurement, but I'm willing to bet it will take several decades using basic time complexity analysis
# This is because the recursive function is called multiple times for the same value, which is a waste of time
# Let's try a different method - where we will store the Fibonacci numbers in a list, and then sum the even numbers
# This is an entirely different paradigm to problem solving - it is called dynamic programming, however the topic is too complicated to explain here
# But the idea is to store the results of subproblems, so that we don't have to compute them again

## Solution 2:
# Let's try to generate the Fibonacci sequence using a list

print("Solution 2: List")
start = time.time()
fibonacci_list = [1, 2]
while fibonacci_list[-1] < 4000000:
    fibonacci_list.append(fibonacci_list[-1] + fibonacci_list[-2])
sum_of_even_fibonacci = sum([i for i in fibonacci_list if i % 2 == 0])
print("Sum of even-valued terms in Fibonacci sequence below 4000000:", sum_of_even_fibonacci)
end = time.time()
print("Time taken (ns):", end - start) # 0.0 ns

# This method is much faster than the recursive function, and it is the most efficient way to solve this problem
# It is a good example of how dynamic programming can be used to solve problems more efficiently
# Now let's consider summing to a larger number, like 4 billion